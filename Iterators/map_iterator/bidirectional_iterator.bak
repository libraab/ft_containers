#pragma once
#include "../../stack.hpp"
#include "node.hpp"

namespace ft {
/*██████╗     ██╗    ██████╗     ██╗    ██████╗     ███████╗     ██████╗    ████████╗    ██╗     ██████╗     ███╗   ██╗     █████╗     ██╗
  ██╔══██╗    ██║    ██╔══██╗    ██║    ██╔══██╗    ██╔════╝    ██╔════╝    ╚══██╔══╝    ██║    ██╔═══██╗    ████╗  ██║    ██╔══██╗    ██║
  ██████╔╝    ██║    ██║  ██║    ██║    ██████╔╝    █████╗      ██║            ██║       ██║    ██║   ██║    ██╔██╗ ██║    ███████║    ██║
  ██╔══██╗    ██║    ██║  ██║    ██║    ██╔══██╗    ██╔══╝      ██║            ██║       ██║    ██║   ██║    ██║╚██╗██║    ██╔══██║    ██║
  ██████╔╝    ██║    ██████╔╝    ██║    ██║  ██║    ███████╗    ╚██████╗       ██║       ██║    ╚██████╔╝    ██║ ╚████║    ██║  ██║    ███████╗
  ╚═════╝     ╚═╝    ╚═════╝     ╚═╝    ╚═╝  ╚═╝    ╚══════╝     ╚═════╝       ╚═╝       ╚═╝     ╚═════╝     ╚═╝  ╚═══╝    ╚═╝  ╚═╝    ╚══════╝
                    ██╗    ████████╗    ███████╗    ██████╗      █████╗     ████████╗     ██████╗     ██████╗
                    ██║    ╚══██╔══╝    ██╔════╝    ██╔══██╗    ██╔══██╗    ╚══██╔══╝    ██╔═══██╗    ██╔══██╗
                    ██║       ██║       █████╗      ██████╔╝    ███████║       ██║       ██║   ██║    ██████╔╝
                    ██║       ██║       ██╔══╝      ██╔══██╗    ██╔══██║       ██║       ██║   ██║    ██╔══██╗
                    ██║       ██║       ███████╗    ██║  ██║    ██║  ██║       ██║       ╚██████╔╝    ██║  ██║
                    ╚═╝       ╚═╝       ╚══════╝    ╚═╝  ╚═╝    ╚═╝  ╚═╝       ╚═╝        ╚═════╝     ╚═╝  ╚═*/
    // --> https://en.cppreference.com/w/cpp/iterator/bidirectional_iterator
    // --> https://cplusplus.com/reference/iterator/BidirectionalIterator/?kw=bidirectional+iterator
    template <class K, class V>
    class bidirectional_iterator_tag {

        typedef bidirectional_iterator_tag                      iterator;
        typedef Node<K, V>                                      myNode;

        myNode*               _root;
        myNode*               _node;
        myNode*               _prev_node;
        ft::stack<myNode*>    _node_stack;
        ft::stack<myNode*>    _prev_node_stack;
        //------------------------------------------------------------------
        void pushLeft(myNode *n) {
            while (n) {
                _node_stack.push(n);
                n = n->left;
            }
        }
        //------------------------------------------------------------------
        void find_predecessor() {
            if (_node->left != nullptr) {
                _prev_node = _node->left;
                while (_prev_node->right != nullptr)
                    _prev_node = _prev_node->right;
            } else {
                _prev_node = nullptr;
                Node *cur = _root;
                while (cur != _node) {
                    if (cur->key < _node->key) {
                        _prev_node = cur;
                        cur = cur->right;
                    } else
                        cur = cur->left;
                }
            }
        }
        //------------------------------------------------------------------
        void find_successor() {
            if (_node->right != nullptr) {
                _prev_node = _node->right;
                while (_prev_node->left != nullptr)
                    _prev_node = _prev_node->left;
            } else {
                _prev_node = nullptr;
                Node *cur = _root;
                while (cur != _node) {
                    if (cur->key > _node->key) {
                        _prev_node = cur;
                        cur = cur->left;
                    } else
                        cur = cur->right;
                }
            }
        }
        //=========================================================//
        //   C O N S T R U C T O R S   &    D E S T R U C T O R    //
        //=========================================================//
        bidirectional_iterator_tag() : _node(nullptr), _prev_node(nullptr) {}
        bidirectional_iterator_tag(myNode *n) : _node(n), _prev_node(nullptr) {pushLeft(n);}
        bidirectional_iterator_tag(const bidirectional_iterator_tag &other) { 
            _node = other._node;
            _prev_node = other._prev_node;
            _node_stack = other._node_stack;
            _prev_node_stack = other._prev_node_stack;
        }
        ~bidirectional_iterator_tag() {}
        //=========================================================//
        //        A S S I G N M E N T           O P E R A T O R    //
        //=========================================================//
        iterator& operator=(const iterator& other) {
            _node = other._node;
            return *this;
        }
        //=========================================================//
        //   I N C R E M E N T       &         D E C R E M E N T   //
        //=========================================================//
        iterator& operator++() { // prefix increment
            if (_node_stack.empty()) {
                _node = nullptr;
                return *this;
            }
            _node = _node_stack.top();
            _node_stack.pop();
            _prev_node = _node;
            _prev_node_stack.push(_node);
            pushLeft(_node->right);
            return *this;
        }
        iterator operator++(int) { // postfix increment
            iterator tmp(*this);
            operator++();
            return tmp;
        }
        iterator& operator--() { // prefix decrement
            if (_prev_node_stack.empty()) {
                _node = nullptr;
                return *this;
            }
            _prev_node = _prev_node_stack.top();
            _prev_node_stack.pop();
            _node = _prev_node;
            pushLeft(_node->left);
            return *this;
        }
        iterator operator--(int) { // postfix decrement
            iterator tmp(*this);
            operator--();
            return tmp;
        }
        //=========================================================//
        //        C O M P A R A I S O N         O P E R A T O R    //
        //=========================================================//
        // Equality operator
        bool operator==(const iterator& other) const {
            return (_node == other._node);
        }
        // Inequality operator
        bool operator!=(const iterator& other) const {
            return (!(_node == other._node));
        }
        // // Dereference operator
        // ft::pair<const Key_type, value_type>& operator*() const {
        //     return (ft::make_pair(_node->key, _node->value));
        // }
        // // Arrow operator
        // ft::pair<const Key_type, value_type>* operator->() const {
        //     return &(operator*());
        // }
    };
}