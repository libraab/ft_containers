In C++98, there's no built-in support for a vector data structure.
However, you can emulate a vector-like functionality by
- using an array
- & implementing functions to handle resizing
- & other common vector operations

Here's an example of a basic Vector class in C++98:
//==============================================================================
class Vector {
private:
    int* data;
    int size;
    int capacity;

public:
    Vector() {
        size = 0;
        capacity = 8; 
        data = new int[capacity];
    }

    ~Vector() {
        delete[] data;
    }

    void push_back(int value) {
        if (size == capacity) {
            resize();
        }
        data[size++] = value;
    }

    void pop_back() {
        if (size > 0) {
            size--;
        }
    }

    int& operator[](int index) {
        return data[index];
    }

    int at(int index) {
        if (index < 0 || index >= size) {
            throw "Index out of range";
        }
        return data[index];
    }

    int getSize() {
        return size;
    }

    int getCapacity() {
        return capacity;
    }

private:
    void resize() {
        capacity *= 2;
        int* newData = new int[capacity];
        for (int i = 0; i < size; i++) {
            newData[i] = data[i];
        }
        delete[] data;
        data = newData;
    }
};
//==============================================================================
This Vector class has basic functionality like :

push_back()
pop_back()
operator[]
at()
getSize()
getCapacity()

It uses an array to store the data
It automatically resizes the array when the capacity is reached
It is important to note that C++98 does not have move semantics
So when resizing the array the elements need to be copied individually.

//==============================================================================
You can use this Vector class like this:

Vector v;
v.push_back(1);
v.push_back(2);
v.push_back(3);

cout << v.at(1) << endl; // prints 2
cout << v.getSize() << endl; // prints 3
cout << v.getCapacity() << endl; // prints 8
//==============================================================================
I did not include an allocator_type.
An allocator_type is a class template that's used to manage memory allocation and deallocation for container classes
such as std::vector.

In C++98, allocators were not a part of the standard library, so they had to be implemented manually.
It's not necessary to include an allocator_type in the Vector class that I provided
because it simply uses the new and delete operators to manage memory allocation & deallocation.
However, to have more control over memory management or to use custom memory allocation, just implement an allocator_type.
C++11 introduces the std::allocator, which is a class that can be used as an allocator_type for container classes.
The std::allocator provides a standard-compliant & general-purpose allocator that can be used with many different types of memory resources.
//==============================================================================
Here's an implementation with an allocator_type

template <typename T, typename Alloc = std::allocator<T>>
class Vector {
private:
    Alloc alloc;
    T* data;
    int size;
    int capacity;

public:
    Vector() : size(0), capacity(8), data(alloc.allocate(capacity)) { }

    ~Vector() {
        for (int i = 0; i < size; ++i) {
            alloc.destroy(&data[i]);
        }
        alloc.deallocate(data, capacity);
    }

    void push_back(const T& value) {
        if (size == capacity) {
            resize();
        }
        alloc.construct(&data[size++], value);
    }

    void pop_back() {
        if (size > 0) {
            alloc.destroy(&data[--size]);
        }
    }

    T& operator[](int index) {
        return data[index];
    }

    T at(int index) {
        if (index < 0 || index >= size) {
            throw "Index out of range";
        }
        return data[index];
    }

    int getSize() {
        return size;
    }

    int getCapacity() {
        return capacity;
    }

private:
    void resize() {
        capacity *= 2;
        T* newData = alloc.allocate(capacity);
        for (int i = 0; i < size; i++) {
            alloc.construct(&newData[i], data[i]);
            alloc.destroy(&data[i]);
        }
        alloc.deallocate(data, capacity);
        data = newData;
    }
};
//==============================================================================
In this example, the Vector class template takes two template arguments:
- the type of the elements stored in the vector (T)
- an allocator class (Alloc)

By default, it uses std::allocator, which is a class that can be used as an allocator_type for container classes.
The allocator class provides several member functions such as: 
- allocate()
- construct()
- destroy()
- deallocate()
which are used to manage memory allocation and deallocation.

This example uses the default constructor of the allocator
which will use the global new and delete operators to allocate and deallocate memory.

This version is not a production-ready code & it has some limitations
For example, it does not handle exceptions, it does not have a copy constructor or copy assignment operator.
//==============================================================================

